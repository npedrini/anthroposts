// Generated by Enterprise IDE Plugin from IDE factory L.L.C.
package net.looklisten.notes.controllers
{
	import ch.badmojo.color.Color;
	import ch.badmojo.color.ColorWheel;
	
	import mx.collections.ArrayCollection;
	import mx.collections.Sort;
	import mx.collections.SortField;
	import mx.resources.ResourceManager;
	import mx.rpc.AsyncToken;
	import mx.rpc.events.ResultEvent;
	import mx.utils.StringUtil;
	
	import net.looklisten.notes.layouts.INotesLayout;
	import net.looklisten.notes.model.NotesModel;
	import net.looklisten.notes.soap.BaseNotes;
	import net.looklisten.notes.soap.Category;
	import net.looklisten.notes.soap.CategoryArray;
	import net.looklisten.notes.soap.Location;
	import net.looklisten.notes.soap.LocationArray;
	import net.looklisten.notes.soap.Note;
	import net.looklisten.notes.soap.NoteArray;
	import net.looklisten.notes.soap.Type;
	import net.looklisten.notes.soap.TypeArray;
	import net.looklisten.sound.SoundManager;
	
	public class NotesController 
	{
		private var _notesModel:NotesModel=NotesModel.getInstance();
		//	webservice
		private var notesService:BaseNotes = new BaseNotes();
		
		private static var __instance:NotesController;
		
		function NotesController()
		{
			if(__instance!=null) {
				throw new Error("Singleton already instantiated");
			}
		}
		
		/**
	    * Manages sequence of startup events so they can be executed one at a time 
	    * (enabling user notification of app load activity semi-specifically)
	    */
	    public function initLoadSequence(stepId:int = 1):void
	    {
	    	this[_notesModel.loadOperations[_notesModel.loadOperationId]]();
	    }
	    
	    /** stuff to do once external data has been loaded	*/
	    private function onLoadProcessComplete():void
	    {
	    	_notesModel.loadOperationId++;
	    	
	    	if(_notesModel.loadOperationId<_notesModel.loadOperations.length){
	    		initLoadSequence();
	    	}else{
	    		_notesModel.dataLoaded = true;
	    		_notesModel.loadOperationName = ResourceManager.getInstance().getString("resources","operation.updating.view");
	    	}
	    }
	    
		//	webservice operations and handlers
		private function getNotes(cid:int = 0,tid:int = 0):void
		{
			var token:AsyncToken = notesService.getNotes(cid,tid,Constants.DEBUG?50:0);
			token.addEventListener(ResultEvent.RESULT, onGetNotes);
			//	update model's load-related properties
			_notesModel.loading = true;
			_notesModel.loadOperationName = ResourceManager.getInstance().getString("resources","operation.loading.note.data");
		}
		private function onGetNotes(result:ResultEvent):void
		{
			var __notes:NoteArray = result.result as NoteArray;
			//	alphabetize
			if(__notes!=null)
			{
				var sort:Sort = new Sort();
				sort.fields = [new SortField('content')];
				__notes.sort = sort;
				__notes.refresh();
			}
			//	pass notes to model
			setNotes(__notes);
			//	compose a list of notes w/ mp3s based on `has_audio` property
			var mp3s:Array = new Array();
			for each(var note:Note in __notes)
				if(note.has_audio)
					mp3s.push(Constants.MP3_ROOT+"/"+note.id+".mp3");
			//	play the mp3s randomly...
			//	every 10th of a second w/ 85% probability
			SoundManager.getInstance().playRandomList(mp3s,.1,85,.1,.2,true,true);
			
			_notesModel.loading=false;
			onLoadProcessComplete();
		}
		
		//	note categories
		private function getCategories():void
		{
			var token:AsyncToken = notesService.getCategories();
			token.addEventListener(ResultEvent.RESULT, onGetCategories);
			//	update model's load-related properties
			_notesModel.loading = true;
			_notesModel.loadOperationName = ResourceManager.getInstance().getString("resources","operation.loading.category.data");
		}
		private function onGetCategories(result:ResultEvent):void
		{
			var results:CategoryArray = result.result as CategoryArray;
			setCategories(results);
			organizeCategories();
			
			_notesModel.loading=false;
			onLoadProcessComplete();
		}
		
		//	note types
		private function getTypes():void
		{
			var token:AsyncToken = notesService.getTypes();
			token.addEventListener(ResultEvent.RESULT, onGetTypes);
			//	update model's load-related properties
			_notesModel.loading=true;
			_notesModel.loadOperationName = ResourceManager.getInstance().getString("resources","operation.loading.type.data");
		}
		private function onGetTypes(result:ResultEvent):void
		{
			var results:TypeArray = result.result as TypeArray;		
			setTypes(results);
			
			_notesModel.loading=false;
			onLoadProcessComplete();
		}
		
		//	note locations
		private function getLocations():void
		{
			var token:AsyncToken = notesService.getLocations();
			token.addEventListener(ResultEvent.RESULT, onGetLocations);
			//	update model's load-related properties
			_notesModel.loading=true;
			_notesModel.loadOperationName = ResourceManager.getInstance().getString("resources","operation.loading.location.data");;
		}
		private function onGetLocations(result:ResultEvent):void
		{
			var results:LocationArray = result.result as LocationArray;		
			setLocations(results);
			
			_notesModel.loading=false;
			onLoadProcessComplete();
		}
	    
		public function setNotes(notes:NoteArray):void
		{
			_notesModel.notes = notes;
			filterNotes();
		}
		
		public function setTypes(types:TypeArray):void{
			
			_notesModel.types = types;
			if(types!=null && types.length)
			{
				_notesModel.typesIndexed  = new Array();
				for each(var type:Object in types)
					if(type is Type)
						_notesModel.typesIndexed [int(type.id)] = type;
			}
		}
		
		public function setCategories(categories:CategoryArray):void{
			
			_notesModel.categories = categories;
			if(categories!=null && categories.length)
			{
				_notesModel.categoriesIndexed  = new Array();
				for each(var category:Object in categories)
					if(category is Category)
						_notesModel.categoriesIndexed [int(category.id)] = category;
			}
		}
		
		public function setLocations(locations:LocationArray):void{
			_notesModel.locations = locations;
			if(locations!=null && locations.length)
			{
				_notesModel.locationsIndexed  = new Array();
				for each(var location:Object in locations)
					if(location is Location)
						_notesModel.locationsIndexed [int(location.id)] = location;
			}
		}
		
		public function setLayout(layout:INotesLayout):void{
			if(_notesModel.layout == layout) return;
			
			_notesModel.layout = layout;
			//	TODO: does this need to be done here, every time?
			updateSort();
		}
		
		public function setSortField(sortField:SortField):void{
			_notesModel.sortField = sortField;
			updateSort();
		}
		
		public function filterNotes():void
		{
			if(_notesModel.notes==null || !_notesModel.notes.length)
			{
				_notesModel.notesFiltered = new NoteArray();
				return;
			}
			
			var notesFiltered:NoteArray = new NoteArray();
			
			var i:int
			var note:Note;
			var includeNote:Boolean;
			
			for(i=0;i<_notesModel.notes.length;i++)
			{
				note = _notesModel.notes.getItemAt(i) as Note;
				includeNote = true;
				if(_notesModel.filterCategoryId > 0 && note.category_id != _notesModel.filterCategoryId) includeNote = false;
				if(_notesModel.filterTypeId > 0 && note.type_id != _notesModel.filterTypeId) includeNote = false;
				if(_notesModel.filterLocationId > 0 && note.location_id != _notesModel.filterLocationId) includeNote = false;
				
				/*
				if(_notesModel.sortField!=null)
					if(_notesModel.sortField.name=="found_date")
						if(note.found_date==null)
							includeNote = false;
				*/
				
				if(includeNote) notesFiltered.addItem(note);
			}
			
			_notesModel.notesFiltered = notesFiltered;
			
			//	COMPUTE NOTE CONNNECTIONS
			if(notesFiltered!=null && notesFiltered.length)
			{
				var words:Array = new Array();
				var note_content:String;
				var note_words:Array;
				
				//	iterate over notes
				for(i=0;i<notesFiltered.length;i++)
				{
					note = notesFiltered.getItemAt(i) as Note;
					note_content = note.content;
					note_content = note_content.replace(new RegExp("\\r\\n","g")," ");
					note_content = note_content.replace(new RegExp("[&()-.:]$","g")," ");
					note_words = note_content.split(" ");
					//if(note.has_audio) trace('note '+note.id+' has audio');
					//	for each word in the note, add it to `words` array
					for(var j:int=0,key:String;j<note_words.length;j++)
					{
						key = StringUtil.trim(note_words[j]);
						if(key!="") 
						{
							if(words[key]!=null && words[key].length && words[key].indexOf(note.id)==-1)
							{
								(words[key] as Array).push(note.id);
							}
							else
							{
								try{
									words[key] = [note.id];	
								}catch(e:Error){}
							}
						}
					}
				}
				
				var connections:ArrayCollection = new ArrayCollection();
				for(key in words)
				{
					//	weed out connections that are only one character long
					if(key.length<=3) continue;
					//	weed out connections for which there are only two members
					if(words[key].length<=1) continue;
					//	weed out numbers
					if(isNaN(parseInt(key)))
						connections.addItem({word:key,notes:words[key]});	
				}
				_notesModel.connections = connections;
			}
		}
		
		public function organizeCategories():void{
			
			if(_notesModel.categories==null) return;
			
			var c:Category;
			var pc:Category;
			
			var children:Array=new Array();
			
			var categories:CategoryArray = _notesModel.categories;
			for(var i:int = categories.length-1;i>0;i--){
				pc = categories.source[i] as Category;
				for(var j:int = 0;j<categories.length;j++){
					c = categories.source[j] as Category;
					if(c!=null && c.parent_id == pc.id){
						children.push( c );
					}
				}
			}
			
			for(i=0;i<categories.length;i++){
				for(j = 0;j<children.length;j++){
					if(categories.source[i] == children[j]){
						categories.source.splice(i,1);
					}
				}
			}
			
			for(i = categories.length-1;i>0;i--){
				pc = categories.source[i] as Category;
				for(j = 0;j<children.length;j++){
					c = children[j] as Category;
					if(c.parent_id == pc.id){
						categories.source.splice(i+1,0,c);
					}
				}
			}
			_notesModel.categories = categories;
		}
		
		private function updateSort():void{
			//	apply sort
			if(_notesModel.sortField!=null && _notesModel.layout!=null 
				&& _notesModel.layout.sortable){
				var sort:Sort = new Sort();
				sort.fields=[_notesModel.sortField];
				sort.compareFunction = _notesModel.sortField.name=="color_hex"?compareColors:null;
				_notesModel.notesFiltered.sort = sort;
				_notesModel.notesFiltered.refresh();
			}
			else
			{
				_notesModel.notesFiltered.sort = null;
				_notesModel.notesFiltered.refresh();
			}
		}
		
		private function compareColors(item1:Object,item2:Object, fields:Array = null):int
		{
			var c1:Color = new Color();
			c1.setValueWithHex( item1.color_hex );
			
			var c2:Color = new Color();
			c2.setValueWithHex( item2.color_hex );
			
			if(c1.getHue() > c2.getHue()) {
				return -1;
			}else if(c1.getHue() == c2.getHue()) {
				return 0;	
			}else if(c1.getHue() < c2.getHue()) {
				return 1;
			}
			return -1;
		}
		
		private function hexToRgb(hex:int):Object
		{
			var r:Number = hex >> 16;
  			var temp:Number = hex ^ r << 16;
			var g:Number = temp >> 8;
			var b:Number = temp ^ g << 8;
			return {r:r/255,g:g/255,b:b/255};
		}
		
		public static function getInstance():NotesController
		{
			if(__instance==null) {
				__instance = new NotesController();
			}
			return __instance;
		}
	}

}